# CppTcpSocketServer-With-Unity-Source-Code
유니티 엔진과 C++ 프로젝트 간 TCP 소켓 통신을 구현했던 프로젝트의 소스 코드.  
고급게임서버프로그래밍 수업 기말 과제.  
개인적인 욕심으로 이것저것 추가로 더 작업해보게 되었다.  


---

## 제작 기간
2023.12.01 - 2023.12.12  


## 아쉬운 점
현재 상태에서 개선할 점이 아직 많이 있음. 이는 이후 서버 공부를 더 해볼 때 적용될 예정.  
대부분은 버그 수정에 시간을 쏟은 것 같다...  

또한, 서버 작업에 주력하느라 **유니티 쪽의 코드는 상당히 많이 지저분하게 작성되어 있다.**  
이 또한 아쉬운 점 중 하나...  


# 마주했던 '실패'들
- 멀티스레드 프로그래밍을 본격적으로 해본 것은 처음이라, 처음 보는 이슈들을 여럿 마주함  
	- 스레드 내에서 다른 스레드를 만들고 join()하면, 만들어진 스레드가 끝날 때까지 Blocking되는 현상  
		- join()의 개념을 다시 한 번 짚어가게 되었음.  
	- '교착 상태'를 2번이나 마주하여, 밤샘을 자주 하였음...  
		- 평소 lock_guard를 사용하기도 하고, 스레드 풀에 작업시키니까 어느 정도 안전하다고 생각하여 방심했던 것이 원인  
		- 깊게 깊게 들어가다 보니 동일한 mutex를 다시 만나게 되었던 데드락, mutex 순서가 엇갈리게 되어 발생했던 데드락...  
		- mutex는 '최대한 적게' 사용하는 것이 좋음을 깨닫고, recursive_mutex나 unique_mutex 등 여러 종류가 있다는 것을 깨닫게 되었음.  
	- 데이터 테어링(찢김)이 발생했던 현상  
		- 여러 스레드가 공유 자원을 수정하는데 mutex가 걸려있지 않은 부분이 하나 있었음. 다행히도 Ctrl+F5가 아니라 항상 F5만 누르는 습관이 생겨 금방 해결.  
  
- 클라이언트에서 채팅 수신은 되는데, UI에만 이상하게 업데이트가 안 되었던 현상  
	- 진짜 시간 많이 들였는데, 알고 보니 수신된 채팅 크기가 4092칸이라 UI에 업데이트가 되지 않았던 것  
	- 역직렬화 과정에서 문제가 생겼음을 알고 수정하게 되었음...  
	
- 역직렬화 구현 과정에서, 64비트를 쓰는 타입들(long long, double 등)만 역직렬화가 제대로 이루어지지 않던 현상  
	- 당시 비트 시프트를 사용하여 역직렬화를 구현 중이었는데, 비트 시프트의 단위는 32비트라는 것을 알게 되었음  
	- 비트 시프트 전에 형변환을 먼저 수행하도록 변경하여 해결.  
	- 이 문제도 정말 시간 많이 쏟았는데... CS 지식이 부족함을 통감하게 되었음.  
	
- iterator를 남용하다가 iterator가 무효화되어 계속 Assertion이 발생하던 문제  
	- iterator를 단기간 사용하는 것은 큰 문제가 없지만, 함수에 넘기고 넘기고... 오래 작업하다보니 '무효화'되어서, 이 문제가 어디에서 발생했는지 추적하는 데 시간을 많이 할애함.  
	
- 앞선 문제들을 추적하기에 std::cout이나 printf는 너무 빈약했던 문제  
	- C++ 오픈소스 로깅 라이브러리 spdlog를 사용하여 해결. 로그의 중요성을 다시 한 번 깨닫게 되다.  
	- 그냥 로그 생각날 때마다 하나씩 넣어야지 수준이 아니라, 정말 이곳저곳 다 넣어놓아야 추적하기가 편리하다는 것을 몸소 깨닫게 됨.  
	
- 조건문 작성 실수로 생긴 문제  
	- 플레이어 3이 보낸 메시지를 서버에서 플레이어 1이 보낸 것으로 간주하고 처리하는 이슈가 생겼었음.  
	- 정말 정말 정말 많은 시간을 할애하여 문제를 찾아보고 있었으나.... 문제가 발생한 부분은 조건문 작성 실수였음....  
		- `if(player->info.playerId != -1)`이라고 써야 하는데... `if(player->info.playerId)`라고 쓰여 있었다.  
	- 조건문 작성 시 더욱 꼼꼼하게 살펴봐야겠다는 교훈을 얻게 되었음.  
	
- std::shared_ptr에 의해 크래시가 발생하던 문제  
	- 생성자에서 다른 객체를 생성하면서 잠시 자기 자신의 shared_ptr을 넘겨주어야 할 일이 있어서, std::enable_shared_from_this를 상속하여, 생성자에서 shared_from_this()를 호출하여 객체를 생성하고 있었음.  
	- 사실, 생각해보면 생성자가 끝나고 나서야 shared_ptr이 생성되기 때문에 생성자에 넣어서는 안 되는 코드가 맞긴 했음.  
	- 다음에는 해당 기능을 사용하게 될 때 이 문제를 인지하고 같은 실수를 반복하지 않을 것.  
	
- `for (auto& pair : actorMap)` 순회 중 `pair`이 자꾸 empty가 되던 현상  
	- for문에서 `nullptr` 체크도 분명히 있음에도 발생하였기에, 문제를 추적하느라 또 시간을 보내게 되었음.  
	- for문 마지막에서, 해당 pair의 key를 erase하는 함수를 호출했었는데, 이 때문에 오류가 발생했던 것.  
		- 'for문 마지막에 했으니 오류가 발생할 일은 없겠지?' 라고 안일하게 생각했던 것이 원인.  
		- 또한 mutex를 최대한 짧은 범위 내에서 끝내고 싶은 욕심 때문이기도 했음.  
		- 지울 key값들을 반복문에서 따로 수집해서, 추가 반복문을 수행해 제거하도록 수정하여 해결.(전부 지우는 코드였음)  
		
		
# 도움이 되었던 것들
- 오픈소스 로깅 라이브러리 `spdlog`에 무한한 감사  
- 로비-룸 구조, 전체적인 서버 구조, 액터 간 움직임 동기화 작업 구현 전에 각각 '설계'를 해 보았음.  
	- 이렇게 미리 설계를 해 보고 작업을 시작하는 것이 상당히 도움이 많이 되었음.  
	- 물론, 구현 과정에서 더 좋은 아이디어가 생각나거나, 내가 예상했던 대로 되지 않는 경우도 있어서 설계대로 흘러가지는 않았지만... 어떻게 만들어야 할 지 정도는 그려지는 상태로 작업하니, 처음 마주하는 문제도 꼼꼼히 들여다볼 수 있었음.  
- 러버덕 디버깅  
	- 하다가 막혔을 때 허공에 대고 '내가 지금 만들려고 하는 것은 무엇이지?'를 자세히 설명하는 방식의 디버깅.  
	- 진짜 잘 통한다. 이거 덕분에 문제를 상당히 많이 해결했다.  
- 언리얼 엔진  
	- 언리얼 엔진의 액터 리플리케이션 구조를 참고했는데, 이는 액터 움직임 동기화 설계에 많은 도움이 되었다.  
	- 물론, 에픽게임즈 관계자가 내 코드를 보면 '언리얼 엔진을 참고하고도 이딴 구조라고?'라고 멱살을 잡을지도 모르지만... 내게는 많은 도움이 되었다.  
- 교수님께서 수업에서 제공해주신 CVSP 프로토콜.  
	- 내가 이것저것 필요한 기능 더 넣고 하다보니 점점 나만의 프로토콜이 되어가긴 했지만, 기본 구조가 좋았기 때문에 수월하게 된 것이라고 생각한다.  